# Creating middleware <VersionBadge version="v2.0.0+" />

<Callout>
Middleware is still in pre-release mode. You can use it by installing v2.0.0 using the `next` tag.

<CodeGroup forceTabs>
```sh {{ title: "npm" }}
npm install inngest@next
```
```sh {{ title: "pnpm " }}
pnpm install inngest@next
```
```sh {{ title: "Yarn" }}
yarn add inngest@next
```
</CodeGroup>
</Callout>

Creating middleware means defining the lifecycles and subsequent hooks in those lifecycles to run code in. Lifecycles are actions such as a function run or sending events, and individual hooks within those are where we run code, usually with a _before_ and _after_ step.

Middleware is created using the `InngestMiddleware` class.

**`new InngestMiddleware(options): InngestMiddleware`**

<Row>
     <Col>
          <Properties nested>
               <Property name="name" type="string" required>
                    Used primarily for debugging and logging.
               </Property>
               <Property name="register" type="function" required>
                    A function that will be called when the Inngest client is created, used to set up your middleware and return the lifecycle hooks you wish to use.
               </Property>
          </Properties>
     </Col>
     <Col>
          ```ts
          // Create a new middleware
          const myMiddleware = new InngestMiddleware({
            name: "My Middleware",
            register: () => {
              return {};
            },
          });
          ```
          ```ts
          // Register it on the client
          const inngest = new Inngest({
            name: "My App",
            middleware: [myMiddleware],
          });
          ```
     </Col>
</Row>

As you can see above, we start with the `register` function, which is called when the client is initialized.

```ts
import { InngestMiddleware } from "inngest";

new InngestMiddleware({
  name: "Example Middleware",
  register() {
    // This runs when the client is initialized
    // Use this to set up anything your plugin needs
    return {};
  },
});
```

Function registration, lifecycles, and hooks can all be with synchronous or `async` functions. This makes it easy for our `register` to do some async work, like setting up a database connection.

```ts
new InngestMiddleware({
  name: "Example Middleware",
  async register() {
    const db = await connectToDatabase();

    return {};
  },
});
```

<Callout>
It's possible for a single application to utilize multiple Inngest clients, so always run plugin set-up within the `register()` function instead of globally.
</Callout>

## Specifying lifecycles and hooks

Notice we're returning an empty object `{}`. From here, we can instead return the lifecycles we want to use for this client. See the [Middleware - Lifecycle - Hook reference](/docs/reference/middleware/lifecycle#hook-reference) for a full list of available hooks.

Let's use the `run` lifecycle to execute some code during a function run.

```ts
new InngestMiddleware({
  name: "Example Middleware",
  async register() {
    const db = await connectToDatabase();

    return {
      run({ ctx, fn, steps }) {
        // This will run when a function run starts
        // JS closures allow me to use variables (like `db`) from the outer register() scope
        return {
          beforeExecution() {
            // This will run just before new code is executed
          },
        };
      },
    };
  },
});
```

Here we use the `beforeExecution()` hook within the `run()` lifecycle.

The use of [closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) here means that our `run()` hook can access anything from the plugin's initialization, like our `db` connection.

`run()` here is also called for every function execution, meaning you can run code specific to this execution without maintaining any global state. We can even conditionally register hooks based on incoming arguments. For example, here we only register a hook for a specific event trigger:

```ts
new InngestMiddleware({
  name: "Example Middleware",
  async register() {
    return {
      run({ ctx, fn, steps }) {
        // Register a hook only if this event is the trigger
        if (ctx.event.name === "app/user.created") {
          return {
            beforeExecution() {
              console.log("Function executing with user created event");
            },
          };
        }

        // Register no hooks if the trigger was not `app/user.created`
        return {};
      },
    };
  },
});
```

## Adding configuration

It's common for middleware to require additional customization or options from developers. For this, we recommend creating a function that takes in some options and returns the middleware.

```ts {{ title: "inngest/middleware/myMiddleware.ts" }}
import { InngestMiddleware } from "inngest";

export const createMyMiddleware = (logEventOutput: string) => {
  return new InngestMiddleware({
    name: "My Middleware",
    register() {
      return {
        run({ ctx, fn, steps }) {
          if (ctx.event.name === logEventOutput) {
            return {
              output({ result, step }) {
                console.log(
                  `${logEventOutput} output: ${JSON.stringify(result)}`
                );
              },
            };
          }

          return {};
        },
      };
    },
  });
};
```

```ts {{ title: "inngest/client.ts" }}
import { createMyMiddleware } from "./middleware/myMiddleware";

export const inngest = new Inngest({
  name: "My Client",
  middleware: [createMyMiddleware("app/user.created")],
});
```

<Callout>
Make sure to let TypeScript infer the output of the function instead of strictly typing it; this helps Inngest understand changes to input and output of arguments. See [Middleware - TypeScript](/docs/reference/middleware/typescript) for more information.
</Callout>

## Next steps

Check out some of the samples below for a quick look at middleware in action:

- [Example: Adding Sentry error reporting and tracing](/docs/reference/middleware/examples#adding-sentry-error-reporting-and-tracing)
- [Example: Adding Prisma to function context](/docs/reference/middleware/examples#adding-prisma-to-function-context)

Or see the next pages to walk through the details:

- [Lifecycle](/docs/reference/middleware/lifecycle) - middleware ordering and see all available hooks
- [TypeScript](/docs/reference/middleware/typescript) - how to affect input and output types and values
