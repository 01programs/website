# Advanced: Middleware <VersionBadge version="v2.0.0+" />

<Callout>
Middleware is still in pre-release mode. You can use it by installing v2.0.0 using the `next` tag.

<CodeGroup forceTabs>
```sh {{ title: "npm" }}
npm install inngest@next
```
```sh {{ title: "pnpm " }}
pnpm install inngest@next
```
```sh {{ title: "Yarn" }}
yarn add inngest@next
```
</CodeGroup>
</Callout>

Middleware allows you to specify functions to run at various points in an Inngest client's lifecycle, such as during a function's execution or when sending an event. Use the `InngestMiddleware` class to define new middleware.

```ts
const myMiddleware = new InngestMiddleware({
  name: "My Middleware",
  register() {
    return {
      run({ fn }) {
        // This will be logged whenever a function is executed
        console.log(`Function ${fn.name} is running!`);
        return {};
      },
    };
  },
});

const inngest = new Inngest({
  name: "My App",
  middleware: [myMiddleware],
});
```

This can be used for a wide range of uses, for example:

- Utilizing error-monitoring libraries (e.g. [Sentry](https://sentry.io/))
- Adding logging support
- Transforming input and output data (e.g. [superjson](https://github.com/blitz-js/superjson))
- Setting DB connections before starting a function's execution
- Using Inngest's `step` building blocks to build reusable patterns

Check out some of the samples below for a quick look at how to use middleware:

- [Example: Adding Sentry error reporting and tracing](#adding-sentry-error-reporting-and-tracing)
- [Example: Transforming input and output data (todo)](#)
- [Example: Adding Prisma to function context](#adding-prisma-to-function-context)

## Creating

Middleware is created using the `InngestMiddleware` class.

**`new InngestMiddleware(options): InngestMiddleware`**

<Row>
     <Col>
          <Properties nested>
               <Property name="name" type="string" required>
                    Used primarily for debugging and logging.
               </Property>
               <Property name="register" type="function" required>
                    A function that will be called when the Inngest client is created, used to set up your middleware and return the lifecycle hooks you wish to use.
               </Property>
          </Properties>
     </Col>
     <Col>
          ```ts
          const myMiddleware = new InngestMiddleware({
            name: "My Middleware",
            register: () => {
              return {};
            },
          });
          ```
          ```ts
          const inngest = new Inngest({
            name: "My App",
            middleware: [myMiddleware],
          });
          ```
     </Col>
</Row>

<Callout>
ðŸ’¡ All hooks can be synchronous or `async` functions - the SDK will always wait until a middleware's hook has resolved before continuing to the next one.
</Callout>

The `register()` function can return functions for two separate lifecycles to hook into.

<Row>
     <Col>
          ### `run`

          Triggered when a function is going to be executed.

          <Properties name="Input" nested>
               <Property name="ctx" type="object">
                    The input data for the function. Only `event` and `runId` are available at this point.
               </Property>
               <Property name="steps" type="array">
                    An array of previously-completed steps and their `data`.
               </Property>
               <Property name="fn" type="InngestFunction">
                    The function that is about to be executed.
               </Property>
          </Properties>

          <Properties name="Output" nested>
               <Property name="input" type="function">
                    Called once the input for the function has been set up. This is where you can modify the input before the function starts.

                    Has the same input as the containing `run()` function, but with a complete `ctx` object, including `step` tooling.

                    <Properties name="Output" nested collapse>
                         <Property name="ctx" type="object">
                              An object that will be merged with the existing function input to create a new input.
                         </Property>
                         <Property name="steps" type="array">
                              An array of modified step data to use in place of the current step data.
                         </Property>
                    </Properties>
               </Property>
               <Property name="beforeMemoization" type="function">
                    Called before the function starts to memoize state (running over previously-seen code).
               </Property>
               <Property name="afterMemoization" type="function">
                    Called after the function has finished memoizing state (running over previously-seen code).
               </Property>
               <Property name="beforeExecution" type="function">
                    Called before the function starts to execute (running code seen for the first time).
               </Property>
               <Property name="afterExecution" type="function">
                    Called after the function has finished executing.
               </Property>
               <Property name="output" type="function">
                    Called after the function has finished executing and before the response is sent back to Inngest. This is where you can modify the output.

                    <Properties name="Input" nested collapse>
                         <Property name="result" type="object" required>
                              An object containing the data to be sent back to inngest in the `data` key, and an original `error` (if any) that threw.
                         </Property>
                         <Property name="step" type="object">
                              If this execution ran a step, will be a step that ran.
                         </Property>
                    </Properties>

                    <Properties name="Output" nested collapse>
                         <Property name="result" type="object">
                              An object containing a `data` key to overwrite the data that will be sent back to Inngest for this step or function.
                         </Property>
                    </Properties>
               </Property>
               <Property name="beforeResponse" type="function">
                    Called after the output has been set and before the response has been sent back to Inngest. Use this to perform any final actions before the request closes.
               </Property>
          </Properties>
     </Col>
     <Col>
          ```ts
          const myMiddleware = new InngestMiddleware({
            name: "My Middleware",
            register({ client, fn }) {
              return {
                run: ({ ctx, fn, steps }) {
                  return {
                    input({ ctx, fn, steps }) {
                      // ...
                    },
                    beforeMemoization() {
                      // ...
                    },
                    afterMemoization() {
                      // ...
                    },
                    beforeExecution() {
                      // ...
                    },
                    afterExecution() {
                      // ...
                    },
                    output({ result, step }) {
                      // ...
                    },
                    beforeResponse() {
                      // ...
                    },
                  };
                },
              };
            },
          });
          ```
     </Col>
</Row>

---

<Row>
     <Col>
          ### `sendEvent`

          Triggered when an event is going to be sent.

          <Properties name="Output" nested>
               <Property name="input" type="function">
                    Called before the events are sent to Inngest. This is where you can modify the events before they're sent.
               </Property>
               <Property name="output" type="function">
                    Called after events are sent to Inngest. This is where you can perform any final actions and modify the output from `inngest.send()`.
               </Property>
          </Properties>
     </Col>
     <Col>
          ```ts
          const myMiddleware = new InngestMiddleware({
            name: "My Middleware",
            register: ({ client, fn }) => {
              return {
                sendEvent() {
                  return {
                    input({ payloads }) {
                      // ...
                    },
                    output() {
                      // ...
                    },
                  };
                },
              };
            },
          });
          ```
     </Col>
</Row>

## Registering and order

Middleware can be added in two places: when instantiating an Inngest client via `new Inngest()`, and when creating a function via `inngest.createFunction()`.

```ts
// Adding middleware to a client
const inngest = new Inngest({
  name: "My App",
  middleware: [fooMiddleware, barMiddleware],
});

// Adding middleware to a function
inngest.createFunction(
  { name: "Example", middleware: [bazMiddleware] },
  { event: "test" },
  async () => {
    // ...
  }
);
```

Adding middleware contributes to an overall "stack" of middleware. If you multiple middlewares, each hook will be executed in the following order:

1. All middleware registered on the **client**, in descending order
2. All middleware registered on the **function**, in descending order

<Row>
     <Col>
     For example:

     ```ts
     const logMiddleware = (value: number) =>
       new InngestMiddleware({
         name: `Log on Run: ${value}`,
         register() {
           return {
             run() {
               console.log(value, "- run started");

               return {
                 beforeExecution() {
                   console.log(value, "- before execution");
                 },
                 afterExecution() {
                   console.log(value, "- after execution");
                 },
               };
             },
           };
         },
       });

     const inngest = new Inngest({
       name: "My App",
       middleware: [logMiddleware(1), logMiddleware(2)],
     });

     inngest.createFunction(
       {
         name: "Example",
         middleware: [logMiddleware(3), logMiddleware(4)],
       },
       { event: "test" },
       async () => {
         // ...
       }
     );
     ```
     </Col>
     <Col>
     Output:
     ```
     1 - run started
     2 - run started
     3 - run started
     4 - run started
     1 - before execution
     2 - before execution
     3 - before execution
     4 - before execution
     1 - after execution
     2 - after execution
     3 - after execution
     4 - after execution
     ```
     </Col>
</Row>

## Examples

The following examples show how you might use middleware in some real-world scenarios.

### Adding Sentry error reporting and tracing

The following example uses middleware with [Sentry](https://sentry.io/?ref=inngest) to add exception handling and tracing to function runs while adding searchable context to each log.

```ts
import * as Sentry from "@sentry/node";

const sentryMiddleware = new InngestMiddleware({
  name: "Sentry Middleware",
  register({ client }) {
    // Initialize Sentry as soon as possible, creating a hub
    Sentry.init({ dsn: "..." });

    // Set up some tags that will be applied to all events
    Sentry.setTag("inngest.client.name", client.name);

    return {
      run({ ctx, fn }) {
        // Keep adding context as we go deeper
        Sentry.setTags({
          "inngest.function.id": fn.id(client.name),
          "inngest.function.name": fn.name,
          "inngest.event": ctx.event.name,
          "inngest.run.id": ctx.runId,
        });

        // Start a transaction for this run
        const transaction = Sentry.startTransaction({
          name: "Inngest Function Run",
          op: "run",
          data: ctx.event,
        });

        let memoSpan: Sentry.Span;
        let execSpan: Sentry.Span;

        return {
          input() {
            return {
              ctx: {
                // Add the Sentry client to the input arg so our
                // functions can use it directly too
                sentry: Sentry.getCurrentHub(),
              },
            };
          },
          beforeMemoization() {
            // Track different spans for memoization and execution
            memoSpan = transaction.startChild({ op: "memoization" });
          },
          afterMemoization() {
            memoSpan.finish();
          },
          beforeExecution() {
            execSpan = transaction.startChild({ op: "execution" });
          },
          afterExecution() {
            execSpan.finish();
          },
          output({ result, step }) {
            // Capture step output and log errors
            if (step) {
              Sentry.setTags({
                "inngest.step.name": step.name,
                "inngest.step.op": step.op,
              });

              if (result.error) {
                Sentry.captureException(result.error);
              }
            }
          },
          async beforeResponse() {
            // Flush all events before closing the request
            transaction.finish();
            await Sentry.flush();
          },
        };
      },
    };
  },
});
```

### Adding Prisma to function context

The following is an example of adding a [Prisma](https://www.prisma.io/?ref=inngest) client to all Inngest functions, allowing them immediate access without needing to create the client themselves.

While this example uses Prisma, it serves as a good example of mutating function input to perform crucial setup for your functions to keep them to just business logic.

<Callout>
ðŸ’¡ Types are inferred from middleware outputs, so your Inngest functions will see an appropriately-typed `prisma` property in their input.
</Callout>

```ts
import { PrismaClient } from "@prisma/client";

const prismaMiddleware = new InngestMiddleware({
  name: "Prisma Middleware",
  register() {
    const prisma = new PrismaClient();

    return {
      run(ctx) {
        return {
          input(ctx) {
            return {
              ctx: {
                prisma,
              },
            };
          },
        };
      },
    };
  },
});

// When defining a function...
inngest.createFunction(
  { name: "Example" },
  { event: "app/user.created" },
  async ({ prisma }) => {
    await prisma.user.create(/* ... */);
  }
);
```
