---
category: "Getting started"
title: "How Inngest works"
slug: "how-inngest-works"
position: 1
---


To automatically run workflows in real time, the first step is to send event data to Inngest using our [event format](/docs/event-format-and-structure).  Once we receive them you can start configuring workflows.  You can do this using our dashboard, or with code.  The only remaining step is to publish the workflow, then we'll automatically run it every time we receive the event.

There's more that you can do with Inngest.  You can run your own code whenever events are received (whether it's already on a platform like Lambda or Cloudflare or if you have a Docker container).  Workflows can also handle complex functionality.  Let's take a look.

## The executor engine 

The executor engine is built to ensure that your workflows run reliably and timely.  When new [events are ingested](/docs/event-apis-and-integrations) our executor tests the event and its data against every workflow to check which ones to run.

The engine takes care of scheduling parallel serverless functions, waiting for new events that match specific criteria, manual approvals, creating audit trails, and retrying things if external services are intermittently down.

### Flexibility

Workflows are flexible:  they can do anything, as they run regular code.  Workflows can also be built and configured via the UI, with typing and error detection built in.  For example, changing the content of a push notification is easy to do with zero developer experience and, whilst the integration is pre-built, the push notification code can be entirely engineering driven.

This allows developers to pass off managing high-level aspects of workflows to team members responsible for managing the flows, freeing engineering time.  Workflows are fully versioned, so rolling back or scheduling deploys in the future is a single click away.

## Managing events

Inngest can consume events from every service you use.  We automatically produce a type schema for each version of an event and automatically detect the user responsible for the event.
